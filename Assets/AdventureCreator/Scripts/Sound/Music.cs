/*
 *
 *	Adventure Creator
 *	by Chris Burton, 2013-2016
 *	
 *	"Music.cs"
 * 
 *	This script handles the playback of Music when played using the 'Sound: Play music' Action.
 * 
 */

using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Text;

namespace AC
{

	/**
	 * This script handles the playback of Music when played using the 'Sound: Play music' Action.
	 */
	#if !(UNITY_4_6 || UNITY_4_7 || UNITY_5_0)
	[HelpURL("http://www.adventurecreator.org/scripting-guide/class_a_c_1_1_music.html")]
	#endif
	public class Music : Sound
	{

		private List<QueuedMusic> queuedMusic = new List<QueuedMusic>();
		private MusicCrossfade musicCrossfade;

		// Delay
		private float delayTime;
		private int delayAudioID = -1;
		private float delayFadeTime;
		private bool delayLoop;


		private void Awake ()
		{
			musicCrossfade = GetComponentInChildren <MusicCrossfade>();
			playWhilePaused = KickStarter.settingsManager.playMusicWhilePaused;
			surviveSceneChange = true;
			soundType = SoundType.Music;
			Initialise ();

			queuedMusic.Clear ();

			if (musicCrossfade == null)
			{
				ACDebug.LogWarning ("The 'Music' script requires a 'MusicCrossfade' component to be attached as a child component.");
			}
		}


		public override void _Update ()
		{
			float deltaTime = Time.deltaTime;
			if (KickStarter.stateHandler.gameState == GameState.Paused)
			{
				if (KickStarter.settingsManager.playMusicWhilePaused)
				{
					deltaTime = Time.fixedDeltaTime;
				}
				else
				{
					return;
				}
			}

			if (musicCrossfade)
			{
				musicCrossfade._Update ();
			}

			if (delayAudioID >= 0 && delayTime > 0f)
			{
				delayTime -= deltaTime;

				if (delayTime <= 0f)
				{
					AfterDelay ();
				}
				base._Update ();
			}

			if (queuedMusic.Count > 0 && delayAudioID < 0)
			{
				if (!audioSource.isPlaying)
				{
					queuedMusic.RemoveAt (0);
					if (queuedMusic.Count > 0)
					{
						MusicStorage musicStorage = GetMusic (queuedMusic[0].trackID);
						if (musicStorage != null && musicStorage.audioClip != null)
						{
							SetRelativeVolume (musicStorage.relativeVolume);
							Play (musicStorage.audioClip, queuedMusic[0].trackLoop);
						}
					}
				}
				else if (queuedMusic.Count > 1 && delayAudioID < 0)
				{
					QueuedMusic nextMusic = queuedMusic[1];
					if (nextMusic.fadeTime > 0f)
					{
						// Need to pre-empt next track
						float thresholdProportion = (audioSource.clip.length - nextMusic.fadeTime) / audioSource.clip.length;
						int thresholdSamples = (int) (thresholdProportion * (float) audioSource.clip.samples);

						if (audioSource.timeSamples > thresholdSamples)
						{
							MusicStorage musicStorage = GetMusic (nextMusic.trackID);
							queuedMusic.RemoveAt (0);

							if (nextMusic.isCrossfade)
							{
								if (musicCrossfade)
								{
									musicCrossfade.FadeOut (audioSource, nextMusic.fadeTime);
								}
								audioSource.clip = musicStorage.audioClip;
								SetRelativeVolume (musicStorage.relativeVolume);
								FadeIn (nextMusic.fadeTime, nextMusic.trackLoop);
							}
							else
							{
								FadeOutThenIn (musicStorage, nextMusic.fadeTime, nextMusic.trackLoop);
							}
						}
					}
				}
			}

			base._Update ();
		}


		/**
		 * <summary>Plays a new music track</summary>
		 * <param name = "trackID">The ID number of the track, as generated by the MusicStorage class that stores the AudioClip</para>
		 * <param name = "loop">If True, the new music track will be looped</param>
		 * <param name = "isQueued">If True, the music track will be queued until the current track has finished playing</param>
		 * <param name = "fadeTime">The fade-in duration, in seconds</param>
		 */
		public float Play (int trackID, bool loop, bool isQueued, float fadeTime)
		{
			return HandlePlay (trackID, loop, isQueued, fadeTime, false);
		}


		/**
		 * <summary>Crossfade a new music track</summary>
		 * <param name = "trackID">The ID number of the track, as generated by the MusicStorage class that stores the AudioClip</para>
		 * <param name = "loop">If True, the new music track will be looped</param>
		 * <param name = "isQueued">If True, the music track will be queued until the current track has finished playing</param>
		 * <param name = "fadeTime">The crossfade duration, in seconds</param>
		 */
		public float Crossfade (int trackID, bool loop, bool isQueued, float fadeTime)
		{
			return HandlePlay (trackID, loop, isQueued, fadeTime, true);
		}


		private float HandlePlay (int trackID, bool loop, bool isQueued, float fadeTime, bool isCrossfade)
		{
			if (musicCrossfade)
			{
				musicCrossfade.Stop ();
			}

			MusicStorage musicStorage = GetMusic (trackID);
			if (musicStorage == null || musicStorage.audioClip == null)
			{
				ACDebug.LogWarning ("Cannot play music - no AudioClip assigned!");
				return 0f;
			}
			
			if (isQueued && queuedMusic.Count > 0)
			{
				queuedMusic.Add (new QueuedMusic (trackID, loop, fadeTime, isCrossfade));
				return 0f;
			}
			else
			{
				if (queuedMusic.Count > 0 && queuedMusic[0].trackID == trackID)
				{
					// Already playing, ignore
					return 0f;
				}
				
				/*if (queuedMusic.Count > 0 && queuedMusic[0].trackLoop)
				{
					// Looping current, ignore
					return 0f;
				}*/

				// End other music objects
				Sound[] sounds = FindObjectsOfType (typeof (Sound)) as Sound[];
				foreach (Sound sound in sounds)
				{
					sound.EndOldMusic (this);
				}
				
				bool musicAlreadyPlaying = (queuedMusic.Count > 0) ? true : false;
				
				queuedMusic.Clear ();
				queuedMusic.Add (new QueuedMusic (trackID, loop));
				
				if (musicAlreadyPlaying)
				{
					if (fadeTime > 0f)
					{
						if (isCrossfade)
						{
							if (musicCrossfade)
							{
								musicCrossfade.FadeOut (audioSource, fadeTime);
							}
							audioSource.clip = musicStorage.audioClip;
							FadeIn (fadeTime, loop);
							return fadeTime;
						}
						else
						{
							FadeOutThenIn (musicStorage, fadeTime, loop);
							return (fadeTime * 2f);
						}
					}
					else
					{
						Stop ();
						SetRelativeVolume (musicStorage.relativeVolume);
						Play (musicStorage.audioClip, loop);
						return 0f;
					}
				}
				else
				{
					SetRelativeVolume (musicStorage.relativeVolume);
					
					if (fadeTime > 0f)
					{
						audioSource.clip = musicStorage.audioClip;
						FadeIn (fadeTime, loop);
						return fadeTime;
					}
					else
					{
						Play (musicStorage.audioClip, loop);
						return 0f;
					}
				}
			}
		}


		/**
		 * <summary>Stops the currently-playing music track, and cancels all those in the queue.</summary>
		 */
		public float StopAll (float fadeTime)
		{
			if (fadeTime == 0f && musicCrossfade)
			{
				musicCrossfade.Stop ();
			}

			delayAudioID = -1;
			queuedMusic.Clear ();

			if (fadeTime > 0f && audioSource.isPlaying)
			{
				FadeOut (fadeTime);
				return fadeTime;
			}
			else
			{
				Stop ();
			}
			return 0f;
		}


		private void FadeOutThenIn (MusicStorage musicStorage, float fadeTime, bool loop)
		{
			FadeOut (fadeTime);

			delayTime = fadeTime;
			delayAudioID = musicStorage.ID;
			delayFadeTime = fadeTime;
			delayLoop = loop;
		}


		private void AfterDelay ()
		{
			if (delayAudioID >= 0)
			{
				delayTime = 0f;

				MusicStorage musicStorage = GetMusic (delayAudioID);
				if (musicStorage != null)
				{
					audioSource.clip = musicStorage.audioClip;
					SetRelativeVolume (musicStorage.relativeVolume);
					FadeIn (delayFadeTime, delayLoop);
				}
			}

			delayAudioID = -1;
		}


		private void Resume (int _timeSamples)
		{
			if (queuedMusic.Count > 0)
			{
				MusicStorage musicStorage = GetMusic (queuedMusic[0].trackID);
				if (musicStorage != null && musicStorage.audioClip != null)
				{
					audioSource.clip = musicStorage.audioClip;
					SetRelativeVolume (musicStorage.relativeVolume);
					PlayAtPoint (queuedMusic[0].trackLoop, _timeSamples);
				}
			}
		}


		/**
		 * <summary>Updates a MainData class with its own variables that need saving.</summary>
		 * <param name = "mainData">The original MainData class</param>
		 * <returns>The updated MainData class</returns>
		 */
		public MainData SaveMainData (MainData mainData)
		{
			StringBuilder musicString = new StringBuilder ();
			for (int i=0; i<queuedMusic.Count; i++)
			{
				musicString.Append (queuedMusic[i].trackID.ToString ());
				musicString.Append (SaveSystem.colon);
				musicString.Append ((queuedMusic[i].trackLoop) ? "1" : "0");
				musicString.Append (SaveSystem.colon);
				musicString.Append (queuedMusic[i].fadeTime);
				musicString.Append (SaveSystem.colon);
				musicString.Append ((queuedMusic[i].isCrossfade) ? "1" : "0");
			
				if (i < (queuedMusic.Count-1))
				{
					musicString.Append (SaveSystem.pipe);
				}
			}

			mainData.musicQueueData = musicString.ToString ();
			mainData.musicTimeSamples = 0;

			if (queuedMusic.Count > 0)
			{
				MusicStorage musicStorage = GetMusic (queuedMusic[0].trackID);
				if (musicStorage != null && musicStorage.audioClip != null && audioSource.clip == musicStorage.audioClip && audioSource.isPlaying)
				{
					mainData.musicTimeSamples = audioSource.timeSamples;
				}
			}
			return mainData;
		}
		
		
		/**
		 * <summary>Updates its own variables from a MainData class.</summary>
		 * <param name = "mainData">The MainData class to load from</param>
		 */
		public void LoadMainData (MainData mainData)
		{
			StopAll (0f);

			if (mainData.musicQueueData.Length > 0)
			{
				string[] queueArray = mainData.musicQueueData.Split (SaveSystem.pipe[0]);
				foreach (string chunk in queueArray)
				{
					string[] chunkData = chunk.Split (SaveSystem.colon[0]);

					// ID
					int _id = 0;
					int.TryParse (chunkData[0], out _id);

					// Loop
					int _loop = 0;
					int.TryParse (chunkData[1], out _loop);
					bool loopBool = (_loop == 1) ? true : false;

					// FadeTime
					float _fadeTime = 0f;
					float.TryParse (chunkData[2], out _fadeTime);

					// Crossfade
					int _crossfade = 0;
					int.TryParse (chunkData[3], out _crossfade);
					bool crossfadeBool = (_crossfade == 1) ? true : false;

					queuedMusic.Add (new QueuedMusic (_id, loopBool, _fadeTime, crossfadeBool));
				}

				Resume (mainData.musicTimeSamples);
			}
		}


		private MusicStorage GetMusic (int ID)
		{
			foreach (MusicStorage musicStorage in KickStarter.settingsManager.musicStorages)
			{
				if (musicStorage.ID == ID)
				{
					return musicStorage;
				}
			}
			return null;
		}


		private void SetRelativeVolume (float _relativeVolume)
		{
			relativeVolume = _relativeVolume;
			SetMaxVolume ();
		}

	}


	public struct QueuedMusic
	{

		public int trackID;
		public bool trackLoop;
		public float fadeTime;
		public bool isCrossfade;


		public QueuedMusic (int _trackID, bool _trackLoop, float _fadeTime = 0f, bool _isCrossfade = false)
		{
			trackID = _trackID;
			trackLoop = _trackLoop;
			fadeTime = _fadeTime;

			if (fadeTime > 0f)
			{
				isCrossfade = _isCrossfade;
			}
			else
			{
				isCrossfade = false;
			}
		}

	}

}